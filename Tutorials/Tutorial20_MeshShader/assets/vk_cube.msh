#version 460
#extension GL_NV_mesh_shader : require

// from the task shader
#ifndef GROUP_SIZE
#   define GROUP_SIZE 32
#endif

// use only 24 threads of 32 maximum available
layout(local_size_x = 24) in;

// cube contains 24 vertices, 36 indices for 12 triangles
layout(max_vertices = 24, max_primitives = 12) out;

// output primitive type is triangle list
layout(triangles) out;

// built-in output variables
//out uint gl_PrimitiveCountNV;
//out uint gl_PrimitiveIndicesNV[max_primitives * 3]
//out gl_MeshPerVertexNV {
//  vec4 gl_Position;
//} gl_MeshVerticesNV[max_vertices]
//perprimitiveNV out gl_MeshPerPrimitiveNV {
//  int gl_PrimitiveID;
//  int gl_Layer;
//  int gl_ViewportIndex;
//} gl_MeshPrimitivesNV[max_primitives];

layout(location=0) out vec2 out_UV[];
layout(location=1) out vec4 out_Color[];


layout(std140) uniform CubeData
{
    vec4  sphereRadius;
    vec4  pos[24];
    vec4  uv[24];
    uvec4 indices[36 / 3];
} g_Cube;

layout(std140) uniform Constants
{
    // row major matrices for compatibility with DirectX
    layout(row_major) mat4x4 g_ViewMat;
    layout(row_major) mat4x4 g_ViewProjMat;

    vec4   g_Frustum[6];    // xyz == plane normal, w == distance
    float  g_CoTanHalfFov;
    float  g_ElapsedTime;
    bool   g_FrustumCulling;
    bool   g_Animate;
};

// All task shader output can be accessed by mesh shader
taskNV in Task {
    vec4  pos[GROUP_SIZE];
    float LODs[GROUP_SIZE];
} Input;


// generate color
vec4 Rainbow(float factor)
{
    float h   = factor / 1.35;
    vec3  col = vec3(abs(h * 6.0 - 3.0) - 1.0, 2.0 - abs(h * 6.0 - 2.0), 2.0 - abs(h * 6.0 - 4.0));
    return vec4(clamp(col, vec3(0.0), vec3(1.0)), 1.0);
}

void main()
{
    // work group index used to access task shader output
    const uint gid = gl_WorkGroupID.x;

    // local invocation index used to access mesh shader output
    const uint I   = gl_LocalInvocationID.x;

    vec3  pos   = Input.pos[gid].xyz;
    float scale = Input.pos[gid].w;
    float LOD   = Input.LODs[gid];
    
    // each thread writes to only one vertex
    gl_MeshVerticesNV[I].gl_Position = g_ViewProjMat * vec4(pos + g_Cube.pos[I].xyz * scale, 1.0);
    out_UV[I] = g_Cube.uv[I].xy;

    // LOD doesn't affect on vertices count, just show LOD with different colors
    out_Color[I] = Rainbow(LOD);

    // only 12 threads writes indices
    if (I < 12)
    {
        gl_PrimitiveIndicesNV[I*3+0] = g_Cube.indices[I].x;
        gl_PrimitiveIndicesNV[I*3+1] = g_Cube.indices[I].y;
        gl_PrimitiveIndicesNV[I*3+2] = g_Cube.indices[I].z;
    }

    // only one thread write the primitive count
    if (I == 20)
        gl_PrimitiveCountNV = 12;
}
