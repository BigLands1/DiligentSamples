#include "common.fxh"
#include "oit.fxh"

cbuffer cbConstants
{
    Constants g_Constants;
}

StructuredBuffer<uint> g_OITLayers;
Texture2D<float4>      g_OITTail;

struct PSOutput
{
    float4 Color : SV_TARGET;
};

void main(in PSInput   PSIn,
          out PSOutput PSOut)
{
    float4 Color;
    Color.rgb = ComputeLighting(PSIn.Color.rgb, PSIn.Normal, g_Constants.LightDir.xyz);
    Color.a   = lerp(g_Constants.MinOpacity, g_Constants.MaxOpacity, PSIn.Color.a);

    float Depth = PSIn.Pos.z;
    uint  D     = uint(Depth * 16777215.0);
    float T     = 1.0;
    
    uint Offset = GetOITLayerDataOffset(uint2(PSIn.Pos.xy), g_Constants.ScreenSize);
    uint layer;
    for (; layer < uint(NUM_OIT_LAYERS); ++layer)
    {
        uint LayerDT = g_OITLayers[Offset + layer];
        uint LayerD  = GetOITLayerDepth(LayerDT);
        if (D <= LayerD)
        {
            break;
        }
        float LayerT = GetOITLayerTransmittance(LayerDT);
        T *= LayerT;
    }
    if (layer == uint(NUM_OIT_LAYERS))
    {
        float4 Tail = g_OITTail.Load(int3(PSIn.Pos.xy, 0));
        // Average contribution of all tail pixels.
        T /= (255.0 * Tail.x);
    }

    Color.rgb *= T * Color.a;
    
#if CONVERT_PS_OUTPUT_TO_GAMMA
    // Use fast approximation for gamma correction.
    Color.rgb = pow(Color.rgb, float3(1.0 / 2.2, 1.0 / 2.2, 1.0 / 2.2));
#endif
    PSOut.Color = Color;
}
